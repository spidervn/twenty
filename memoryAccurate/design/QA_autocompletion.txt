
Very simple theory for solving Autocompletion problem.

1. General Terminology 
	i) CommandLineSyntax (cmd_def)
		i1) CommandLineLayout
			i1.1) Layout Assistant syntax
		i2) CommandLineElement
		i3) SwichersDictionary
		i4) SwitcherValue
		
	ii) MatchingSchema
	iii) Token 

	i) CommandLineSyntax
		CommandLineSyntax is a struct desrible a command-line syntax.
		CommandLineElement represent a definition an Elements of a commandLine.
		CommandLineLayout store the layout of a CommandLine (Order of Elements, Validations)
		SwichersDictionary defines all availables switcher in a command line.
		
			CommandName: command line name 
			Switcher: a swicher of a command (is a CommandLineElement as well)
			CommandValue: a string values

		CommandLineSyntax (c_s) = { e, l, s_d }
			e: array of CommandLineElement
			l: array of CommandLineLayout
			s_d: SwichersDictionary			

		CommandLineElement (c_e) = CommandName | Switcher | CommandValue
		CommandLineLayout (c_l) = array( c_e )

		i1.1) Layout Assistant syntax
			One_of(a,b,c...): one of a or b or c
			

	ii) MatchingSchema
		

2. Strategies and Problem solving

Autocompletion:
	scan_autocompletion_()

	scan_element(layout, tokens)
		input: 
			layout
			tokens
		output: 
			matching_schema

	scan_next_element(element, tokens_, s)
		input: 
			element,
			tokens,
			s: start scanning token position
		output:
			matched? 
			s1: match position
			len: number of token 


	auto_complete(cmddef, cmdLine, position)
		tokens = parseToken(cmdLine)
		selectedToken = findSelected(cmdLine, position, tokens)

		matches = findEveryMatchingSchema(cmddef.layouts, tokens)		
		matches_selected = { match | match in matches, match.match_data.position contains selectedToken }

		if (matches_selected.size() > 0)
		{
			suggest = { e.posible_values |  e in matches_selected.element } 
		}

		return suggest

Structs
	matching_schema {
		result: 0,
		match_data: [
			element, 
			position,
			len
		]
	}

Q01) The method for finding selected token?
	Input: 
		(cmd, i)
		Where
			cmd: Command Line (string)
			i: position of cursor (zero index)
	Output:
		(t, j)			
		Where
			t: array of tokens (Words)
			j: index of word (in t) which has the same value with cmd[i] character.



A01) 
	t = parseToken(cmd)
	j = (?)
	
	// Find j (y)
	around_i = str(at_most_5_characters_around_include_i)
	c = find(t, around_i)	// Candidates

	if c.size() == 1
		j = c[0]
	else
	{
		for (c1 in c)
		{
			s = cmd.index_of(c1)

			if (s>= i && i < s + c1.size())
			{
				j = c1
			}
		}
	}

Q02) Quick way for concat two vector ?
	input(v1,v2)
	output(v)

A02)	
	Method1
		v.insert(v.end(), v1.begin(), v1.end())
		v.insert(v.end(), v2.begin(), v2.end())
		
		<=>
		v = concat(v1,v2)

	Method2 (operator overriding)
		v = v1
		v << v2

Q03) Filter a vector by a condition ?
	Input:
		(v, a_condition)
		
		Where:
			v is a vector of data 
			a_condition the condition for filter elements
	Output:
		v2

A03) 
	it = v.begin()
	while (it = v.find_if(it, a_condition) != v.end())
	{
		v2.push_back(*it);
	}

Q04) Method for finding every MatchingSchema?
	Input: (cmd_def, t)
		Where:
			cmd_def: Command line definition
			t: tokens (Array of string)
	Output: array_of m
		Where
			m: is one Matching Schema.
