Problem 01. 
  Hiển thị tùy chọn tại vị trí con nhắc?
Problem 02. 
  Lưu toàn bộ lệnh đang gõ và lịch sử phiên hiện hành vào bộ nhớ 


Abstraction need
		i. Clearly design 
		ii. Not design for change (Change behavior & change system requirements => Must change design)
		iii. Completely API
			<=> If fill enough code into Interface => Works
		iv(*). Deal with not-sure code_able.

Problem 01. Design for curses only?
Problem 02. Design for both curses & boost::msm
Problem 03. Design for both curses & other msm
Problem 04. Detail Curses app abstraction for CommandLine ?
Problem 05. Detail curses app abstraction for QuizWindow ?
Problem 06. Detail curses app abstraction for Memory score ?
Problem 07. Two fds that help ?
Problem 08. Curses independent design ?
Problem 09. Design clearly works for ICurses & ICmdLine?
Problem 10. Design for two ICurses.UI works concurrently with ICurses ?
Problem 11. Design for keyboard handling works with two ICursesUI Conccurently?
Problem 12. Design for mouse & keyboard handling works with two ICursesUI ?
Problem 13. Design for ICmdLine & IWinQuiz ?
Problem 14. Design for IWinQuiz & IDB ?
Problem 15. Design list command support ?
Problem 16. Current cursor autocomplete design ?

Answer 01.
Answer04.
----------
	ICursesCmdLine
		initialize()
		registerEvents()	// Register every Event Handler
Answers 08
----------
	The design:
		ICurses = 
		{
			curses program and
			the most complicated source code and implementation ever in Human history :) ;
			and it works in a seperated thread (not interrupt anyone)
		}

		IOtherProgram = { Program which works with Ncurses }
		Design is 
			IOtherProgram->sendEvent(icurses)
			ICurses->sendEvent(iotherprogram)
		=> This design do not care about what curses is, because ICurses is totally independent.
Answer 09.
----------
	The design
	ICurses
	{
		Most-inner-interaction complex in the world
	}

	ICmdLine
	{
		1 billions line of code in one file.
	}

	Assume that everything (which is not unlogic) is impossible. 
	Design for every detail interface between ICmdLine & ICurses (curses lib).

		ICmdLine.Model = 
		{
			string typo;
			string currentword;
			vector<string> typo_history;
			vector<string> out_put_history;
		}

		ICurses.UI
		{
			// Could implement whatever UI needs for Terminal inside ncurses ability
		}

		ICmdLine.UI : public ICurses.UI {}

	IProgram = 
	{ 
		ICmdLine.UI;
		ICmdLine.Model;
		ICurses
	}

Answer 10.
----------
	Use cases 
		u1 = ICmdLine.UI
		u2 = ICmdLine.UI
	For u1 & u2 take input together => u1 input first then switch to u2 (and vice-versa)
		ICurses.focus(u1)
		ICurses.focus(u2)
	For u1 & u2 waiting Keyboard together
		u_active = { u which is active }
		ICurses.waitKey()
			=> u_active => Recive
	For u1 & u2 waiting Mouse event
		u_active = { u which is active }
		onMouseEvent(e)
			u_active.mouseEvent(e)

Answer 11.
----------
	u1 = ICurses.UI1
	u2 = ICurses.UI2
	ic = ICurses (Curses Main)

	Flow chart of Keyboard Handling

		ic.AddUI(u1);
		ic.AddUI(u2);

		ic.start();
		u1.start();
		u2.start();

		ic.onKeyboard(e)
		u = ic.getActive()
		u.onKeyboard(e)


Answer 12.
----------
	ic = ICurses
	u1 = ICurses.UI
	u2 = ICurses.UI

	Keyboard/Mouse Handling
		ic.addUI(u1);
		ic.addUI(u2);

		ic.start();
		u1.start();
		u2.start();

		e1 = ic.onKeyboard();
		e2 = ic.onMouse();

		ic.enqueueEvent(e1);
		ic.enqueueEvent(e2);

		us = ic.getActives();
		for u : us		
			ic.sendEvent(u, e1)
			ic.sendEvent(u, e2)

Answer 13.
----------
	ic = ICurses
	icm = ICmdLine
	grm = ICmdLine.Grammar
	iqu = IWinQuiz

	icm.add(grm)
	ic.addUI(icm)
	ic.addUI(iqr)

	CmdLine
		icm.onKeyboard()	
			icm.onTyping()			
			icm.Grammar.show()
			icm.Grammar.onSelect()
		icm.onEnter
			icm.Grammar.check()
			icm.onExeCmd()
		icm.onMouse()
			___	
	WinQuiz
		ic.setActive(iqu)
		iqu.onEnter()
		iqu.onCancel()

	Curses
		ic.initialize()
		ic.start()
			iqu.onKeyboard()
			iqu.onEnter()


	Note - More about abstraction
		prog(n) = { a program named N which has 1..billions lines of ultimately complex code }

		parallel([a1,a2,...,an]) = 
			{ A program which has n program run parallel }

		sequence([a1, a2, ..., an]) = 
			{ A program which has n program run in sequence }

		prog(curses)
			= sequence([
				prog(init),
				prog(main_curses),
				prog(end)
			])

	
Answer 14.
----------
	
Answer 15.
----------